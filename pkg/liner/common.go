package liner

import (
	"bufio"
	"container/ring"
	"errors"
	"fmt"
)

type commonState struct {
	terminalSupported bool
	outputRedirected  bool
	inputRedirected   bool
	columns           int
	killRing          *ring.Ring
	ctrlCAborts       bool
	r                 *bufio.Reader
	cursorRows        int
	maxRows           int
	shouldRestart     ShouldRestart
	noBeep            bool
	needRefresh       bool
}

// ShouldRestart is passed the error generated by readNext and returns true if
// the the read should be restarted or false if the error should be returned.
type ShouldRestart func(err error) bool

// ModeApplier is the interface that wraps a representation of the terminal
// mode. ApplyMode sets the terminal to this mode.
type ModeApplier interface {
	ApplyMode() error
}

// ErrInvalidPrompt is returned is a given prompt contains any unprintable runes
// (including substrings that could be colour codes on some platforms).
var ErrInvalidPrompt = errors.New("invalid prompt, unprintable runes not allowed")

// ErrNotTerminalOutput is returned from Prompt or PasswordPrompt if the
// platform is normally supported, but stdout has been redirected
var ErrNotTerminalOutput = errors.New("standard output is not a terminal")

// ErrZeroColums is returned when liner experiences an error that it cannot
// handle. For example, if the number of colums becomes zero during an
// active call to Prompt
var ErrZeroColums = errors.New("number of colums is zero")


func (s *State) promptUnsupported(p string) (string, error) {
	// TODO: check what this actually do
	if !s.inputRedirected || !s.terminalSupported {
		fmt.Print(p)
	}
	linebuf, _, err := s.r.ReadLine()
	if err != nil {
		return "", err
	}
	return string(linebuf), nil
}
